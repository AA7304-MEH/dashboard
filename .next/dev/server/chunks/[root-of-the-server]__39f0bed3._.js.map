{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///D:/linkedin%20content%20generator/app/api/repurpose/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport { GoogleGenerativeAI } from '@google/generative-ai';\r\nimport { auth } from '@clerk/nextjs/server';\r\n\r\nconst genAI = new GoogleGenerativeAI(process.env.GOOGLE_GENERATIVE_AI_API_KEY || '');\r\n\r\nexport async function POST(request: Request) {\r\n    try {\r\n        const { sourceText, url } = await request.json();\r\n        const { userId } = await auth();\r\n\r\n        // Basic validation\r\n        if (!sourceText && !url) {\r\n            return NextResponse.json({ error: 'Text or URL is required' }, { status: 400 });\r\n        }\r\n\r\n        let textToProcess = sourceText;\r\n\r\n        // TODO: Implement actual URL scraping if URL provided\r\n        // For now, if URL is provided but no text, we just treat URL as text (or mock fetch)\r\n        // We'll rely on user pasting text for phase 1 of this feature to be robust\r\n        if (url && !sourceText) {\r\n            // Mock fetch placeholder\r\n            textToProcess = `Content from ${url}`;\r\n        }\r\n\r\n        const model = genAI.getGenerativeModel({ model: \"gemini-2.0-flash\" });\r\n\r\n        const prompt = `Repurpose the following content into LinkedIn formats:\r\n    Content: \"${textToProcess.substring(0, 5000)}\"\r\n\r\n    Output JSON with 3 keys:\r\n    1. \"thread\": A twitter/linkedin thread (array of strings).\r\n    2. \"carousel\": Outline for a document carousel (5 slides, title + content).\r\n    3. \"question\": An engaging discussion question based on the content.\r\n\r\n    Return JSON only.`;\r\n\r\n        const result = await model.generateContent(prompt);\r\n        const response = await result.response;\r\n        let text = response.text();\r\n        text = text.replace(/```json/g, '').replace(/```/g, '').trim();\r\n\r\n        const data = JSON.parse(text);\r\n\r\n        return NextResponse.json(data);\r\n    } catch (error) {\r\n        console.error(\"Repurpose error:\", error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to repurpose content' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,MAAM,QAAQ,IAAI,sLAAkB,CAAC,+EAA4C;AAE1E,eAAe,KAAK,OAAgB;IACvC,IAAI;QACA,MAAM,EAAE,UAAU,EAAE,GAAG,EAAE,GAAG,MAAM,QAAQ,IAAI;QAC9C,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,IAAA,6LAAI;QAE7B,mBAAmB;QACnB,IAAI,CAAC,cAAc,CAAC,KAAK;YACrB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QACjF;QAEA,IAAI,gBAAgB;QAEpB,sDAAsD;QACtD,qFAAqF;QACrF,2EAA2E;QAC3E,IAAI,OAAO,CAAC,YAAY;YACpB,yBAAyB;YACzB,gBAAgB,CAAC,aAAa,EAAE,KAAK;QACzC;QAEA,MAAM,QAAQ,MAAM,kBAAkB,CAAC;YAAE,OAAO;QAAmB;QAEnE,MAAM,SAAS,CAAC;cACV,EAAE,cAAc,SAAS,CAAC,GAAG,MAAM;;;;;;;qBAO5B,CAAC;QAEd,MAAM,SAAS,MAAM,MAAM,eAAe,CAAC;QAC3C,MAAM,WAAW,MAAM,OAAO,QAAQ;QACtC,IAAI,OAAO,SAAS,IAAI;QACxB,OAAO,KAAK,OAAO,CAAC,YAAY,IAAI,OAAO,CAAC,QAAQ,IAAI,IAAI;QAE5D,MAAM,OAAO,KAAK,KAAK,CAAC;QAExB,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO,gJAAY,CAAC,IAAI,CACpB;YAAE,OAAO;QAA8B,GACvC;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}